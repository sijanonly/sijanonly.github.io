<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CODEBUG</title><link>https://sijanb.com.np/</link><description>Data Exploration...</description><atom:link href="https://sijanb.com.np/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:sijanonly@gmail.com"&gt;Sijan Bhandari&lt;/a&gt; </copyright><lastBuildDate>Mon, 06 May 2024 18:58:36 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Machine Learning Glossary: what are model training steps ?</title><link>https://sijanb.com.np/posts/machine-learning-glossary-what-are-model-training-steps/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;p&gt;There may exist many possible models to solve a given problem at hand. Based on your modeling decision there are usually two different ways to complete the machine learning lifecycle.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;1st scenario. Training a single model with a training dataset and final evaluation with the test set.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2nd scenario. Training multiple models with training/validation dataset and final evaluation with the test set.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In case of (1st scenario), you will follow the following approach:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Divide the data into training and test sets. (Usually 70/30 splits)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Select your preferable model.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Train it with a training dataset.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Assess the trained model in the test set. (no need to perform validation in your trained model)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In case of (2nd scenario), you will follow the following approach:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Divide the data into training, validation, and test sets. (Usually 50/25/25 splits)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Select the initial model/architecture.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Train the model with a training dataset.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Evaluate the model using the validation dataset.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Repeat steps (b) through (d) for different models or training parameters.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Select the best model based on evaluation and train the best model with combined (training + validation) datasets.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Assess the trained model in the test set.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description><category>machine-learning</category><guid>https://sijanb.com.np/posts/machine-learning-glossary-what-are-model-training-steps/</guid><pubDate>Mon, 06 May 2024 18:51:31 GMT</pubDate></item><item><title>Machine Learning Glossary: what is model training in machine learning ?</title><link>https://sijanb.com.np/posts/machine-learning-glossary-what-is-model-training-in-machine-learning/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;p&gt;The Machine Learning model is represented by the model parameters. Those parameters are the learnable parameters. Learning happens when these parameters are updated with suitable values and the model is able to solve the given tasks.
Training is the process of feeding a training dataset to your model. The training process uses an objective function (example MSE) to get the feedback in each iteration. Since we are trying to improve the accuracy of the model on a given
input, and lower the error between model prediction and actual output, we also called training process as a model optimization process.&lt;/p&gt;</description><category>machine-learning</category><guid>https://sijanb.com.np/posts/machine-learning-glossary-what-is-model-training-in-machine-learning/</guid><pubDate>Mon, 06 May 2024 17:59:07 GMT</pubDate></item><item><title>Machine Learning Glossary: what is machine learning ?</title><link>https://sijanb.com.np/posts/machine-learning-glossary-what-is-machine-learning/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;p&gt;Understanding and extracting hidden patterns or features from the data is the learning process in machine learning. Instead of using explicit
logic supplied by people, machine learning has the capacity to learn from experiences.
Conventional systems are created with the use of well defined human-set rules. In order for machine learning algorithms
to understand complicated patterns from inputs (x), they use outputs (y) as a feedback signal. Thus, an intelligent program is the ML system's
final product.&lt;/p&gt;
&lt;p&gt;We often use a logical method to solve any issue. We make an effort to break the task up into several smaller tasks and solve each smaller task
using a distinct rationale. When dealing with extremely complicated jobs, like stock price prediction, the patterns are always changing,
which has an impact on the results.
That implies that, in order to answer this problem logically, we must adjust our handwritten logic for each new change in the outputs.
Machine Learning (ML), on the other hand, creates the model using a vast amount of data. The data gives the model all of its historical experience,
which helps it better understand the pattern. We just retrain the model with fresh instances whenever the data changes.&lt;/p&gt;</description><category>machine-learning</category><guid>https://sijanb.com.np/posts/machine-learning-glossary-what-is-machine-learning/</guid><pubDate>Sun, 05 May 2024 10:28:45 GMT</pubDate></item><item><title>Paper Summary : Playing Atari With Deep Reinforcement Learning</title><link>https://sijanb.com.np/posts/paper-summary-playing-atari-with-deep-reinforcement-learning/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Summary of the paper &lt;a href="https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf"&gt;"Playing Atari with Deep Reinforcement Learning"&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Motivation"&gt;Motivation&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-playing-atari-with-deep-reinforcement-learning/#Motivation"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Deep Learning (DL) has proven to work well when we have large amount of data. Unline supervised DL algorithm setup, Reinforcement Learning (RL) doesn't have direct access to the targets/labels. RL agent usually get "delayed and sparsed" rewards as a signal to understand about the environment and learn policy for a given environment.
Another challenge is about the distribution of the inputs. In supervised learning, each batch in training loop is drawn randomly which make sure each inputs/samples are independent and the parameter updates won't overfit to some specific direction/class in the data. In case of RL, inputs are usually correlated. For example, when you collect image inputs/frames of video of games, their pixel positions won't change much. Therefore, many samples will look alike and this might lead to poor learning and local optimal solution. Another problem is the non-stationarity of the target. The target will be changing throughout the episodes when the agent learns new behaviour from the environment, or adopting well.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Contribution"&gt;Contribution&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-playing-atari-with-deep-reinforcement-learning/#Contribution"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Authors proposed 'Deep Q Network' (DQN) learning algorithm with experience replay. This approach solves both the correlated inputs and non-stationarity problems.&lt;/p&gt;
&lt;p&gt;They uses CNN with a variant of Q-learning algorithm, and uses stochastic gradient descent (SGD) for the training. They maintained a buffer named - 'Experience Replay' of the transitions while the agent nagivates through the environment. While SGD training process, samples from this stored buffer is used to create mini-batches and used for the training of the NN. This refer this NN as Q-network with parameter, $ \theta $, which minimizes the sequences of loss functions $ L_i (\theta_i) $ :&lt;/p&gt;
&lt;p&gt;$ L_i(\theta_i) $ = $ \mathbb{E_{s,a \sim \rho(.)}} [ (y_i - Q(s, a; \theta_i)^2 ] $&lt;/p&gt;
&lt;p&gt;Where $ y_i = \mathbb{E_{s' \sim  \varepsilon}} [ r + \gamma \underset{a'} max (s', a', \theta_{i-}) | s,a] $&lt;/p&gt;
&lt;p&gt;is the target for iteration i.&lt;/p&gt;
&lt;p&gt;They used the previous iteration parameter value ($ \theta_{i-1} $) in order to calculate the target ($y_i$). The parameter ($ \theta_{i-1} $) from previous iteration won't change for some long future iterations, which makes it stationary and training will be smooth. They also  feed concatenation of four video frames as an input to the CNN in order to avoid the partial observation contraints in the learning. Using four frames, CNN will be able locate the movement direction, speed of the objects in the frames.&lt;/p&gt;
&lt;p&gt;DQN is used to train on Atari 2600 games. The video frames from emulator are the observations based on discrete actions (up, down, left, rigth..) of the agent in the environment. The network consists of two convolutional layers and two fully connected layers. The last layer outputs the distribution over possible actions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class="highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://sijanb.com.np/posts/paper-summary-playing-atari-with-deep-reinforcement-learning/</guid><pubDate>Sun, 08 Nov 2020 13:40:42 GMT</pubDate></item><item><title>Paper Summary : Policy Gradient Methods for Reinforcement Learning with Function Approximation</title><link>https://sijanb.com.np/posts/paper-summary-policy-gradient-methods-for-rl-with-function-approximation/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Summary of the paper &lt;a href="https://homes.cs.washington.edu/~todorov/courses/amath579/reading/PolicyGradient.pdf"&gt;"Policy Gradient Methods for Reinforcement Learning with Function Approximation"&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Motivation"&gt;Motivation&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-policy-gradient-methods-for-rl-with-function-approximation/#Motivation"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Reinforcement Learning (RL) solves the problem of learning through experiments in the (dynamic) environments. The learner objective is to find an optimal policy which can guide the agent for the nagivation. This optimal policy is formulated in terms of maximizing future reward of the agent. Value-function $ V_{\pi} (s) $ and action-value function $ Q_{\pi}(s,a) $ are the measure of potential future rewards.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$ V_{\pi} (s) $ : Goodness measure to be in a state s and then following policy $ \pi $&lt;/li&gt;
&lt;li&gt;$ Q_{\pi}(s,a) $ : Goodness measure to be in a state s, perform action a and then follow policy $ \pi $&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NOTE&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Both $ V_{\pi} (s) $ and $ Q_{\pi}(s,a) $ are related to rewards in terms of expectation of the discounted future reards and their values are maintained on a lookup table.&lt;/li&gt;
&lt;li&gt;Goal : We want to find the value of (state) or (state,action) in a given environment, so that the agent can follow an optimal path, collecting maximum rewards.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In a large scale RL problem, maintaining lookup table will lead to the the problem of 'curse of dimensionality'. Currently, this problem is solved using function approximation. The function approximation tries to generalize the estimation of value of state or state-action value based on a set of features in a given state/observations. Most of the existing approaches follow the idea of approximating the value function and then deriving policy out of it. Authors have pointed out two major limitations of this approach:&lt;/p&gt;
&lt;p&gt;a. This approach focused towards finding deterministic policy, which might not be the case for complex problems/environments.
b. Small variation in the value estimation might cause different action selection; derived policy is sensitive.&lt;/p&gt;
&lt;h5 id="Contribution"&gt;Contribution&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-policy-gradient-methods-for-rl-with-function-approximation/#Contribution"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Authors proposed an alternative way to approximate policy directly using parameterized function. So, we won't be storing any Q-values in a table, but, learnt using a function approximator. For an example, the policy can be represented by a Neural Network (NN) where we can feed state as input and get probability distribution for action selection as output. Considering $ \theta $ as parameters of the NN, representing the policy and $ \rho $ as its performance measure (which can be a loss function), then the parameter $ \theta $ will be updated as:&lt;/p&gt;
&lt;p&gt;$ \theta_{t+1} \gets \theta_t + \alpha \frac{\partial {\rho}}{ \partial{\theta}} $&lt;/p&gt;
&lt;h6 id="Policy-Gradient-Theorem:"&gt;Policy Gradient Theorem:&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-policy-gradient-methods-for-rl-with-function-approximation/#Policy-Gradient-Theorem:"&gt;¶&lt;/a&gt;&lt;/h6&gt;&lt;p&gt;For any Markov Decision Process (MDP),&lt;/p&gt;
&lt;p&gt;$ \nabla_{\theta} J(\theta) = \frac{\partial {\rho(\pi)}}{ \partial{\theta}} = \underset{s} \sum d^{\pi} (s)  \underset{a} \sum \frac{\partial{\pi(s,a)}}{\partial(\theta)} Q^{\pi}(s,a) $ ----------(a)&lt;/p&gt;
&lt;p&gt;Here $ \rho(\pi) $ , the average rewards under current policy ($ \pi $) and $ d^{\pi}(s) $, stationary distribution of states under $ \pi $&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The problem with the above formulation is 'how to get Q(s,a) ?' -&amp;gt; Q(s,a) must be estimated.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can see that the state distribution is independent of policy parameter $ \theta $. Since, gradient is independent of MDP dynamics, it allows model-free learning in RL. If we estimate the policy gradient using Monte-Carlo sampling, it will give REINFORCE algorithm.&lt;/p&gt;
&lt;p&gt;In Monte-Carlo sampling, we take N trajectories using current policy $ \pi $ and collect the returns. However, these returns hae high variance and we might need many episodes for the smooth convergence. The variance is introduced due to the fact that we won't be able to collect same trajectories multiple times(.i.e movement of agent is also dynamic) using out stochastic policies in the stochastic environment.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QUESTION : How to estimate Q-value in equation (a) ?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Authors used a function approximation $ f_w (s,a) $ with parameters 'w' to estimate $ Q^{\pi} (s,a) $ as :&lt;/p&gt;
&lt;p&gt;$ \nabla_{\theta} J(\theta) =  \underset{s} \sum d^{\pi(s)} (s)  \underset{a} \sum \frac{\partial{\pi(s,a)}}{\partial(\theta)} f_w(s,a) $ --------- (b)&lt;/p&gt;
&lt;p&gt;Here $ f_w(s,a) $ is learnt by following $ \pi $ and updating 'w' by minimizing mean-square error between Q-values $ [ Q^{\pi}(s,a) - f_w(s,a) ]^2 $. The neural network/policy will predict some Q-value and also when agent take some action in the environment, we predict Q-value for a given state/action. Algorithm will try to make sure difference between these two remains as close as possible.&lt;/p&gt;
&lt;p&gt;The resulting formulation (b) gives the idea of actor-critic architecture for RL where&lt;/p&gt;
&lt;p&gt;i. $ \pi(s,a) $ is the actor which is learning to approximate the policy by maximixing (b)&lt;/p&gt;
&lt;p&gt;ii. The critic $ f_w(s,a) $ learning to estimate the policy by minimizing MSE with estimated and true Q-values.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class="highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://sijanb.com.np/posts/paper-summary-policy-gradient-methods-for-rl-with-function-approximation/</guid><pubDate>Sat, 31 Oct 2020 20:18:54 GMT</pubDate></item><item><title>Paper Summary : Proximal Policy Optimization Algorithms</title><link>https://sijanb.com.np/posts/paper-summary-proximal-policy-optimization-algorithms/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Summary of the paper &lt;a href="https://arxiv.org/abs/1707.06347"&gt;"Proximal Policy Optimization Algorithms"&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Motivation"&gt;Motivation&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-proximal-policy-optimization-algorithms/#Motivation"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Deep Q learning, 'Vanilla' Policy Gradient, REINFORCE are the examples of approaches for function approximation in RL. When it comes to RL, robustness and sample efficiency are the measures that defines effectivenss of the applied algorithm.&lt;/p&gt;
&lt;p&gt;In RL formulation, the agent needs to solve a task/problem in an envronment. Agent countinously interacts with the environment, which provides rewards to the agent, and thereafter agent learns a policy to navigate and tackle the problem. In every time step, RL agent has to make a decision by selecting preferrable action. To do so, agent fully relies on the information of current state and accumulated knowledge (history of rewards) up to current time step. Once the action is performed, the next state/observation is defined by some (stochastic) transition probability model. Also, reward will be signaled to the agent based on this new state information and performed action to get there. In overall, the goal of the agent is to maximize expected cumulative rewards.&lt;/p&gt;
&lt;p&gt;In terms of RL, this goal can be formulated as finding a policy $ \pi (a_t | s_t) $ such that expected reward $ \mathbb{E_{\pi_{\theta, \tau}}} [G_t] $ is maximized.&lt;/p&gt;
&lt;p&gt;In high dimensional/ countinous action space, policy gradient method can be used to solve this problem. In "vanilla" policy gradient method, the policy is parameterized by some parameter $ \theta $ .i.e parametric policy  $ \pi_{\theta} (a_t | s_t) $ and we directly optimize the policy by finding the optimal parameter $ \theta $.&lt;/p&gt;
&lt;p&gt;Even though 'Vanilla' policy gradient/ REINFORCE are simple/easier to implement, they come with some learning issues:&lt;/p&gt;
&lt;p&gt;PROBLEM : Usually give rise to high variance while estimating gradient. This is because, the objective function&lt;/p&gt;
&lt;p&gt;$ J(\theta) =  \mathbb{E_{\pi_{\theta, \tau}}} (G_t) $&lt;/p&gt;
&lt;p&gt;contains expectation; so we can't directly compute the exact gradient. We use stochatic gradient estimates such as REINFORCE based on some batch of trajectories. This sampling approximation adds some variance. That means, we need large number of trajectories to get the best estimation.
In addition, we can see that collecting trajectories could be a problem in complex environments-might take long time to run.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Contribution"&gt;Contribution&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-proximal-policy-optimization-algorithms/#Contribution"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Authors have introduced a family of policy optimization methods which is build up on the basis of work of Trust-Region Policy optimization. Two main ideas:&lt;/p&gt;
&lt;p&gt;a. Clipped Surrogate Objective Function : It avoids large deviations of learned policy $ \pi_{\theta} $ from old policy $ \pi_{\theta old} $; which is formulated as:&lt;/p&gt;
&lt;p&gt;$ L^{clip}(\theta) = \mathbb{E}_t [ min (r_t (\theta) \hat{A_t}, clip(r_t(\theta), 1 - \epsilon, 1 + \epsilon) \hat{A_t}) ] $&lt;/p&gt;
&lt;p&gt;Here $ r_t(\theta) = \frac{\pi_{\theta}(a_t | s_t)}{\pi_{\theta old}(a_t | s_t)} $&lt;/p&gt;
&lt;p&gt;$ \epsilon $ is hyperparameter, which restricts the new policy from being too far from old policy.
$ \hat{A_t} $ can be discounted return or advantage function.&lt;/p&gt;
&lt;p&gt;The clipping ensures the updates take place in "trust-region". Also, introduces less variance than vanilla gradient methods&lt;/p&gt;
&lt;p&gt;b. Multiple Epochs for policy update:&lt;/p&gt;
&lt;p&gt;PPO allows to run multiple epochs on the same trajectories and optimize the objective $ L^{clip}(\theta) $. This also reduces the sample inefficieny while learning. In order to collect data, PPO runs policy with parallel actors and then samples mini-batches of the data for training k-epochs using the objective function above.&lt;/p&gt;
&lt;p&gt;Let's observe the behaviour of the objective function based on changes in advantage function.&lt;/p&gt;
&lt;p&gt;CASE I : When $ \hat{A_t} $ is +ve :&lt;/p&gt;
&lt;p&gt;The objective function can be written as :&lt;/p&gt;
&lt;p&gt;$ L^{clip} (\theta) = min ( r_t(\theta), 1 + \epsilon ) \hat{A_t} $&lt;/p&gt;
&lt;p&gt;Since $\hat{A_t} $ is +ve, when the action occurrence likelihood increases (i.e. $ \pi_{\theta}(a_t | s_t) $), the whole objective value will also increase.
The min operator limits the increasing objective value. So, when  $ \pi_{\theta}(a_t | s_t) ) &amp;gt; (1 + \epsilon) \pi_{\theta old}(a_t | s_t)  $, ceiling occurs at $ (1 + \epsilon) \hat{A_t} $&lt;/p&gt;
&lt;p&gt;CASE II : When $ \hat{A_t} $ is -ve :&lt;/p&gt;
&lt;p&gt;The objective function can be written as :&lt;/p&gt;
&lt;p&gt;$ L^{clip} (\theta) = max ( r_t(\theta), 1 - \epsilon ) \hat{A_t} $&lt;/p&gt;
&lt;p&gt;Now, the objective function value only increases when the likelihood of the action is less likely (i.e. $ if \pi_{\theta}(a_t | s_t) $ decreases, $ L^{clip} (\theta) $ increases )
In this case, when $  (1 - \epsilon) \pi_{\theta old}(a_t | s_t) &amp;gt; \pi_{\theta}(a_t | s_t) )   $, max operator limits the value at $ (1 - \epsilon) \pi_{\theta old}(a_t | s_t) \hat{A_t} $&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class="highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://sijanb.com.np/posts/paper-summary-proximal-policy-optimization-algorithms/</guid><pubDate>Sat, 31 Oct 2020 16:37:42 GMT</pubDate></item><item><title>Paper Summary : Learning What Data to Learn</title><link>https://sijanb.com.np/posts/paper-summary-learning-what-data-to-learn/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Summary of the paper &lt;a href="https://arxiv.org/pdf/1702.08635.pdf"&gt;"Learning What Data to Learn"&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Motivation"&gt;Motivation&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-learning-what-data-to-learn/#Motivation"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;The performance of learning algorithms based on Machine Learning or Deep Learning rely on amount of training data. Having more data points also has benefit of learning more generalized models and avoiding overfitting. However, collecting data is a painstalking work. Instead, we can learn automatic and adaptive data selection in the training process and make learning faster with minimal data points.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Contribution"&gt;Contribution&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-learning-what-data-to-learn/#Contribution"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;In this paper, authors have introduced  Neural Data Filter (NDF) as an adaptive framework which can learn data selection policy using deep reinforcement learning(DRL) algorithm 'Policy Gradient'.
Two important aspects of this framework:&lt;/p&gt;
&lt;p&gt;a. NDF filter the data instances from randomly fetched mini-batches of data during training process.
b. Training loop provides feedback to NDF policy based on reward signal (e.g. calculated in validation set) and NDF policy is trained using DRL.&lt;/p&gt;
&lt;h6 id="NDF-in-detail"&gt;NDF in detail&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-learning-what-data-to-learn/#NDF-in-detail"&gt;¶&lt;/a&gt;&lt;/h6&gt;&lt;p&gt;NDF is designed to filter out some portion of training data based on some quality measure. The filtered high-quality data points speed up the convergence of the model.&lt;/p&gt;
&lt;p&gt;In order to formulate Markov Decision Process (MDP) in NDF, authors used 'SGD-MDP' with following tuple:
&amp;lt;s, a, P, r, $ \gamma $&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s : representing mini-batch data and current state of training model (weights/biases) as a state&lt;/li&gt;
&lt;li&gt;a : binary filtering actions;  $ a = {\{a_m\}}_{m=1}^M \in (0, 1)^M $, M-batch size and $ a_m \in \{0,1\} $
indicating whether a particular data instance in minibatch will be selected or not.&lt;/li&gt;
&lt;li&gt;P : P(s`| s, a) is a transition probability&lt;/li&gt;
&lt;li&gt;r = r(s,a), reward signal based on performance of the current model under consideration (e.g. validation accuracy),&lt;/li&gt;
&lt;li&gt;$ \gamma \in [0,1] $, discounting factor&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The  NDF policy A(s,a, $ \Theta $) can be represented by a binary classification algorithm such as logistic regression or deep NN, where $ \Theta $ is policy parameter and it is updated as:&lt;/p&gt;
&lt;p&gt;$ \Theta \gets \Theta + \alpha V_t \sum_m \frac{\partial log P_{\Theta} (a_m|s_m)}{\partial \Theta} $&lt;/p&gt;
&lt;p&gt;and, $ V_t $ is the sampled estimation of reward $ R(s_t, a_t) $ from one episode.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class="highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://sijanb.com.np/posts/paper-summary-learning-what-data-to-learn/</guid><pubDate>Sat, 31 Oct 2020 15:33:59 GMT</pubDate></item><item><title>Paper Summary : Curiosity-driven Exploration by Self-supervised Prediction</title><link>https://sijanb.com.np/posts/paper-summary-curiosity-driven-exploration-by-self-supervised-prediction/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Summary of the paper &lt;a href="https://arxiv.org/abs/1705.05363"&gt;"Curiosity-driven Exploration by Self-supervised Prediction"&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Motivation"&gt;Motivation&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-curiosity-driven-exploration-by-self-supervised-prediction/#Motivation"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;The policy learning process in Reinforcement Learning (RL) is usually suffered due to delayed/sparse rewards. Reward is a direct signal for an agent to evaluate 'how good the current action selection is'. Since reward collection takes time, learning optimal policy also takes longer time to derive. Another factor that influence the learning process is human-designed reward function. These reward functions might not represent the optimal guidance for learning of the agent or won't be scalable to real world problems. We need a way to overcome reward sparsity and also improves exploration of the agent to make learning more robust.&lt;/p&gt;
&lt;p&gt;Human learning process is not only guided by the final goal or achievement, but also driven by motivation or curiosity of the being. Curiosity adds exploratory behaviour to the agent, allowing it to acquire new skills and gain new knowledge about the environment. It also makes agent robust to perform actions which ultimately reduces uncertaintly on it's behaviours to capture the consequences of it's own action.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Contribution"&gt;Contribution&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-curiosity-driven-exploration-by-self-supervised-prediction/#Contribution"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;The authors, in this paper, proposed curiosity-driven learning by uing agent-intrinsic reward (.i.e a reward which is learnt by agent itself by understanding the current environment or possible changes in the states while navigation). In order to quantify curiosity, they have introduced "Intrinsic Curiosity Module".&lt;/p&gt;
&lt;h6 id="Intrinsic-Curiosity-Module-(ICM)"&gt;Intrinsic Curiosity Module (ICM)&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-curiosity-driven-exploration-by-self-supervised-prediction/#Intrinsic-Curiosity-Module-(ICM)"&gt;¶&lt;/a&gt;&lt;/h6&gt;&lt;p&gt;The output of ICM is the state prediction error, which serves as reward for curiosity. This module has two sub-components, each represented by neural networks.&lt;/p&gt;
&lt;p&gt;a. Inverse Model :&lt;/p&gt;
&lt;p&gt;This model learns feature space using self-supervision. This new feature space is learnt in order to avoid features/information which are irrelevant to the agent while nagivation. Learning feature space is completed within two sub-modules:&lt;/p&gt;
&lt;p&gt;i) First module encodes the raw input state ($s_t$) into a feature vector ($ \phi(s_t) $)
ii) Second module takes $ \phi(s_t) $ and $ \phi(s_{t+1}) $) as encoded feature inputs and predicts action $ \hat{a_t} $ that agent might take to go to $ s_{t+1} $ from $ s_t $&lt;/p&gt;
&lt;p&gt;$ \hat{a_t} = g(  \phi(s_t), \phi(s_{t+1}), \theta_i ) $&lt;/p&gt;
&lt;p&gt;Here function g represents NN and  $ \hat{a_t} $ is estimated action. The learnable parameters $ \theta_i $ are trained with loss function representing difference between predicted action and actual action. i.e $ L_I( \hat{a_t}, a_t) $&lt;/p&gt;
&lt;p&gt;b. Forward Model :&lt;/p&gt;
&lt;p&gt;This is a NN which predicts the next state ($ s_{t+1} $) with inputs $  \phi(s_t) $ and action executed at $ s_t $.&lt;/p&gt;
&lt;p&gt;$ \hat{\phi(s_{t+1})} = f( \phi(s_t), a_t, \theta_F) $&lt;/p&gt;
&lt;p&gt;$ \hat{\phi(s_{t+1})}$ is the predicted estimation of $ \phi(s_{t+1})$ and $ \theta_F $ represents trainable parameters, with loss function as:&lt;/p&gt;
&lt;p&gt;$ L_F ( \phi(s_{t+1}),  \hat{\phi(s_{t+1})}) = \frac{1}{2} ||  \hat{\phi(s_{t+1})} - \phi(s_{t+1})  ||^2 = \eta L_F $&lt;/p&gt;
&lt;p&gt;Both losses can be jointly expressed as :&lt;/p&gt;
&lt;p&gt;$ \underset{\theta_i, \theta_F} {max} [ (1-\beta) L_I  + \beta L_F ] $&lt;/p&gt;
&lt;p&gt;NOTE:&lt;/p&gt;
&lt;p&gt;** ICM worked with two connected modules - inverse model (which learnt the feature representation of state and next state) and forward model ( which predicts the feature representation of the next state)
** Curiosity can be calculated by the difference between output of forward model i.e $ \hat{\phi(s_{t+1})} $ and output of the inverse model $  \phi(s_{t+1}) $.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class="highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://sijanb.com.np/posts/paper-summary-curiosity-driven-exploration-by-self-supervised-prediction/</guid><pubDate>Sat, 31 Oct 2020 14:40:29 GMT</pubDate></item><item><title>Paper Summary : Asynchronous Methods for Deep Reinforcement Learning</title><link>https://sijanb.com.np/posts/paper-summary-asynchronous-methods-for-deep-reinforcement-learning/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Summary of the paper &lt;a href="https://arxiv.org/abs/1602.01783"&gt;"Asynchronous Methods for Deep Reinforcement Learning"&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Motivation"&gt;Motivation&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-asynchronous-methods-for-deep-reinforcement-learning/#Motivation"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Deep Neural Network (DNN) is introduced to Reinforcement Learning (RL) framework in order to make function approximation easier/scable for large state-space problems. DNN itself suffers from overfitting because of the correlated data while nagivating through the environments (e.g. when we play a game, each consecutive moves of a player withing smaller timeframes looks similar, which won't contribute much for learning). In order to avoid it, people started using experience replay, where we have to store navigation experience (e.g. screenshots in games) as a buffer and we can use them later while training/updating policy/model parameters.&lt;/p&gt;
&lt;p&gt;This works well, but only for off-policy algorithms like Q-learning. How to use on-policy algorithms like SARSA and make it stable learning using DNN ? Also, using experience replay introduces extra memory requirements/ computatonal delay for each update and real interaction with environment.&lt;/p&gt;
&lt;p&gt;**NOTE :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On-policy : The training data is generated by the same policy being trained. e.g : Reinforce&lt;/li&gt;
&lt;li&gt;Off-Policy : The training data generated from another policy can be used to train the current policy. e.g : Q-learning&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Contribution"&gt;Contribution&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-asynchronous-methods-for-deep-reinforcement-learning/#Contribution"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;In this paper, authors introduced an asynchronous training process by executing multiple agents in parallel in different instances of the same environment using multiple CPU cores. It uses multithreading to run those agents and update the global model parameters asynchronously in online fashion. It is reported that this approach enables stable learning and faster convergence speed.&lt;/p&gt;
&lt;p&gt;They have introduced asynchronous variants of SARSA, 1-step/n-step Q learning and advantage actor-critic algorithm. Let's discuss some details on Asynchronous Q-learning and Async. Advantage Actor critic (A3C) algorithms.&lt;/p&gt;
&lt;h6 id="Asynchronous-Q-Learning"&gt;Asynchronous Q-Learning&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-asynchronous-methods-for-deep-reinforcement-learning/#Asynchronous-Q-Learning"&gt;¶&lt;/a&gt;&lt;/h6&gt;&lt;p&gt;In Deep Q-Learning (DQN), the neural network (NN) approximates the Q-value function Q(s,a, $\theta$) with loss formulated as:
$
\begin{equation}
 L_{i} (\theta_i)  = \mathbb{E} [ r + \gamma Q (s^`, a^`, \theta_{i-1}) - Q(s, a, \theta_i) ]^2 ..........(i)
 \end{equation}
 $&lt;/p&gt;
&lt;p&gt;In Async 1-step Q learning, each thread maintains it's own copy of environment and agent traverse through the environment with the help of $  \epsilon $ - greedy policy. At each step, we compute teh gradient of the loss (i) and collect gradients over multiple timesteps before updating the parameters.&lt;/p&gt;
&lt;h6 id="Asynchronous-Advantage-Actor-Critic-(A3C)"&gt;Asynchronous Advantage Actor-Critic (A3C)&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-asynchronous-methods-for-deep-reinforcement-learning/#Asynchronous-Advantage-Actor-Critic-(A3C)"&gt;¶&lt;/a&gt;&lt;/h6&gt;&lt;p&gt;Actor-critic method combines both value-pased and policy based methods.&lt;/p&gt;
&lt;p&gt;It has a policy $ \pi(a_t | s_t; \theta) $ and value function $ V (s_t; \theta_t)$ to be learnt. It uses "forward-view", i.e. selecting actions based on its exploration strategy $ \pi (a_t | s_t; \theta) $ up to some $  t_{max} $  steps in the future, to collect up to $ t_{max} $ rewards since last update.&lt;/p&gt;
&lt;p&gt;Now, policy and value functions are updated after every $ t_max $ actions as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Policy Network : $ \bigtriangledown_{\theta} log \pi(a_t | s_t; \theta) (R_t - V(s_t, \theta_v)) $&lt;/li&gt;
&lt;li&gt;Value Network : $ \bigtriangledown_{v} (R - V(s_t; \theta_v))^2 $&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this learning framework, parallel actor-learners updates a shared model and make learning process more robust and stable&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class="highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://sijanb.com.np/posts/paper-summary-asynchronous-methods-for-deep-reinforcement-learning/</guid><pubDate>Sat, 31 Oct 2020 11:41:55 GMT</pubDate></item><item><title>Paper Summary : Visual Reinforcement Learning Imagined Goals</title><link>https://sijanb.com.np/posts/paper-summary-visual-reinforcement-learning-imagined-goals/</link><dc:creator>Sijan Bhandari</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Summary of the paper &lt;a href="https://arxiv.org/abs/1807.04742"&gt;"Visual Reinforcement Learning with Imagined Goals"&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Motivation"&gt;Motivation&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-visual-reinforcement-learning-imagined-goals/#Motivation"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Humans can easily adjust themselves or adopt to new environments and learn new tasks by setting their own goals. In case of Reinforcement Learning framework, we have to manually design the reward function which gives an orientation towards the goal of a given task. For example, if we have to train a robot to pick a package and deliver to a destination, we have to set reward based on its distance-covered. Along with delivery task, there might be other tasks like adjusting robot-arm to pick the package based on it's shape/size or placing the package at the destination without throwing it on the ground. For each of these tasks, we can design specific-reward functions.But, it won't be practical or scalable for real-world problems where an agent has to solve many tasks synchronously.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h5 id="Contribution"&gt;Contribution&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-visual-reinforcement-learning-imagined-goals/#Contribution"&gt;¶&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;Authors proposed a reinforcement learning framework where an agent can learn general-purpose goal-conditioned polices by setting it's own synthetic goals and learning tasks to achieve those goals, without human intervention.&lt;/p&gt;
&lt;p&gt;They referred this framework as "reinforcement with imagined goals" (RIG).&lt;/p&gt;
&lt;h6 id="Synthetic-Goals"&gt;Synthetic Goals&lt;a class="anchor-link" href="https://sijanb.com.np/posts/paper-summary-visual-reinforcement-learning-imagined-goals/#Synthetic-Goals"&gt;¶&lt;/a&gt;&lt;/h6&gt;&lt;p&gt;Initially, the agent itself generate a set of synthetic goals by exploration through a random policy. Both state observations and goals are the image data (for example in case of robot navigation). By random policy, agent executes some random actions in the environment and the trajectories consisting of state observations are stored for later use.&lt;/p&gt;
&lt;p&gt;During policy training phase, agent can randomly fetch those stored observations as a set of initial states or set of goals.&lt;/p&gt;
&lt;p&gt;Now, we have all the information to train a goal-conditioned agent. Authors used Q-learning agent - Q(s,a,g), where
s - states, a- actions and g-goals to be achieved by executing action 'a'.
And, the optimal policy can be derived as : $  \pi (s,g) = \underset{a} max Q(s,a, g) $&lt;/p&gt;
&lt;p&gt;In order to train this policy, two main issues need to be addressed:&lt;/p&gt;
&lt;p&gt;a. How to design reward function ? Distance between images while nagivation is one possible reward. But, pixel-wise distance won't carry semantic meaning of actual distance between states and this will be also computationally involved.
b. How to represent the goal as a distribution so that we sample goals for the training?&lt;/p&gt;
&lt;p&gt;Authorse resolved these issues by using Variational Autoencoders (VAE), to learn encoded representation of images. The VAE takes raw images (x) as input and generate low-dimensional latent representation (z). Using these latent representation, we have now latent states (z)  and latent goals ($ z_g $).&lt;/p&gt;
&lt;p&gt;The working algorithm can be summarized as :&lt;/p&gt;
&lt;p&gt;a. Initially, agent explores environment using random policy and the state observations will be stored.&lt;/p&gt;
&lt;p&gt;b. VAE will be trained using raw images from (a) to learn latent representation of all state observations.&lt;/p&gt;
&lt;p&gt;c. Initial states (z) and goals ($ z_g $) are sampled from  (b)&lt;/p&gt;
&lt;p&gt;d. Goal-conditioned Q-function Q(z,a, $ z_g $) is trained using data from (c) and policy $ \pi_{\theta} (z, z_g) $ will be learnt in the latent space.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class="highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [ ]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="input_area"&gt;
&lt;div class="highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://sijanb.com.np/posts/paper-summary-visual-reinforcement-learning-imagined-goals/</guid><pubDate>Sat, 31 Oct 2020 09:56:42 GMT</pubDate></item></channel></rss>